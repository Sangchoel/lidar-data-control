# slam_tutorial

이 프로젝트는 RPlidar a1 제품을 사용하여 직접 slam 알고리즘을 만들고 그 원리에 학습함에 있습니다. 
### 1. **ROS (로봇 운영 시스템)**

#### 예시: `#include <ros/ros.h>`
이 줄은 ROS의 핵심 기능을 사용하기 위해 ROS C++ 라이브러리를 포함시키는 것입니다. ROS는 노드, 토픽, 메시지 등을 통해 로봇의 센서 데이터 처리, 명령 전송, 상태 정보 공유 등을 가능하게 하는 프레임워크입니다.

### 2. **라이다 데이터 처리**

#### 예시: `std::vector<float> filtered_ranges = applyGaussianFilter(scan->ranges, 5, 1.0);`
라이다 데이터의 처리는 로봇이 주변 환경을 인식하는 데 핵심적인 역할을 합니다. 이 과정에서 가우시안 필터의 적용은 중요한 단계로, 잡음을 줄이고 데이터의 정확성을 높이는 데 목적이 있습니다. 가우시안 필터는 평균값 주변의 값에 더 큰 가중치를 주어 평활화를 실시하는 방법으로, 수학적으로는 다음과 같은 식으로 표현됩니다:![캡처](https://github.com/Sangchoel/slam_tutorial/assets/158053299/843f4a60-ac19-4098-be7c-c21a8e2f0cf9)
여기서 σ는 표준편차로, 필터의 폭을 결정합니다. 이론적으로 가우시안 필터는 무한한 데이터에 대해 적용되지만, 실제 구현에서는 윈도우 크기를 제한하여 근사적으로 적용합니다. 최근 연구에서는 라이다 데이터의 특성을 고려한 가우시안 필터의 변형이나, 실시간 처리를 위한 효율적인 알고리즘 개발에 초점을 맞추고 있습니다.

### 3. **장애물 감지 및 지도 생성**

#### 예시: `double obstacle_x = robot_x_ + distance * cos(robot_theta_ + angle) / resolution_;`
이 코드는 라이다 센서로부터 측정된 거리(`distance`)와 각도(`angle`)를 바탕으로 장애물의 위치(`obstacle_x`, `obstacle_y`)를 계산합니다. 이 위치 정보는 지도 상에 장애물로 표시되어 로봇이 이를 회피할 수 있게 합니다.
장애물 감지는 로봇이 라이다 센서로부터 받은 데이터를 기반으로 주변 환경에 있는 장애물의 위치를 파악하는 과정입니다. 이는 극좌표계에서 직교좌표계로의 변환을 포함하며, 각 장애물의 위치는 다음과 같이 계산됩니다:![캡처](https://github.com/Sangchoel/slam_tutorial/assets/158053299/c69f1152-42fe-41a0-b8e8-db4f2d9fe853)
여기서 d는 라이다에서 측정된 장애물까지의 거리, θ는 로봇의 방향, α는 라이다 센서에서의 장애물 방향 각도입니다. 이러한 계산을 통해 얻은 장애물의 위치 정보는 지도 생성 과정에서 사용됩니다. 최근 연구에서는 더 정밀한 장애물 위치 파악을 위해 센서 융합 기술이나 딥러닝 기반의 방법론을 탐구하고 있습니다.

### 4. **SLAM (동시적 위치 추정 및 지도 생성)**

#### 개념
SLAM은 로봇이 미지의 환경에서 자신의 위치를 추정하면서 동시에 환경 지도를 생성하는 기술입니다. 이 과정은 크게 두 부분으로 나뉘며, 로컬라이제이션(Localization) 과정에서는 로봇이 현재 위치를 추정하고, 매핑(Mapping) 과정에서는 측정된 데이터를 기반으로 환경의 지도를 구축합니다. SLAM의 핵심적인 도전은 이 두 과정이 서로에게 의존적이라는 점입니다. 최근의 SLAM 연구는 다양한 센서 데이터를 통합하여 정확도와 견고성을 향상시키는 방향으로 진행되고 있으며, 그래프 기반 SLAM, 비쥬얼 SLAM, 딥러닝을 이용한 SLAM 등 다양한 접근 방식이 탐구되고 있습니다.

### 5. **ROS 메시징 및 통신**

#### 예시: `lidar_sub_ = nh_.subscribe("/scan", 1000, &SimpleSLAM::lidarCallback, this);`
이 줄은 `/scan` 토픽에서 라이다 데이터를 구독하고, 데이터가 수신될 때마다 `lidarCallback` 함수를 호출하는 것을 설정합니다. 이를 통해 로봇은 실시간으로 주변 환경의 정보를 받아 처리할 수 있습니다.

### 6. **좌표 변환 및 tf 라이브러리**

#### 예시: (코드 내에서 생략됨)
코드 예제에서는 좌표 변환을 직접 다루는 부분이 생략되었지만, `tf/transform_broadcaster.h` 헤더 파일을 포함시킨 것에서 알 수 있듯, 로봇의 위치 변환 정보를 다루기 위한 준비가 되어 있습니다. `tf` 라이브러리는 로봇의 다양한 부품 사이의 상대적 위치를 관리하는 데 사용됩니다.

### 7. **C++ 프로그래밍 및 ROS 통합**

#### 예시: `class LidarProcessor {...};`
이 클래스는 라이다 데이터 처리를 위한 기능을 캡슐화합니다. C++의 클래스와 객체 지향 프로그래밍 기법을 사용하여 코드의 모듈성과 재사용성을 향상시키는 예입니다.

### 8. **시스템 아키텍처 및 디자인 패턴**

#### 예시: `std::make_unique<LidarProcessor>(map_resolution_, robot_x_, robot_y_, robot_theta_);`
여기서는 C++11의 스마트 포인터 기능을 사용하여 `LidarProcessor` 객체를 안전하게 생성하고 관리합니다. 이는 메모리 누수를 방지하고, 코드의 안정성과 유지 보수성을 향상시킵니다.

각 이론적 개념에 대한 설명과 코드 예시를 통해, 코드가 어떻게 ROS 프레임워크와 C++ 프로그래밍 기법을 사용하여 로봇의 센서 데이터를 처리하고, 로봇이 주변 환경을 인식하며, 내비게이션을 위한 지도를 생성하는지에 대한 이해를 돕고자 했습니다.
